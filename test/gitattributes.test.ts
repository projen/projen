import { synthSnapshot, TestProject, withProjectDir } from "./util";
import { EndOfLine } from "../src/gitattributes";

describe("GitAttributesFile", () => {
  test("should set endOfLine to LF by default", () => {
    withProjectDir((outdir) => {
      // The TestProject already contains a .gitattributes file
      const project = new TestProject({
        outdir,
      });

      const snap = synthSnapshot(project);

      expect(
        snap[".gitattributes"].trim()
          .startsWith(`# ~~ Generated by projen. To modify, edit .projenrc.js and run "npx projen".

* text=auto eol=lf`)
      ).toBe(true);
    });
  });

  test("does not at the endOfLine configuration when disabled", () => {
    withProjectDir((outdir) => {
      // The TestProject already contains a .gitattributes file
      const project = new TestProject({
        outdir,
        gitOptions: {
          endOfLine: EndOfLine.NONE,
        },
      });

      const snap = synthSnapshot(project);

      const lines: string[] = snap[".gitattributes"]
        .split("\n")
        .map((line: string) => line.trim());

      expect(lines).not.toContain("* text=auto eol=lf");
    });
  });

  test("applies the endOfLine option when defined", () => {
    withProjectDir((outdir) => {
      // The TestProject already contains a .gitattributes file
      const project = new TestProject({
        outdir,
        gitOptions: {
          endOfLine: EndOfLine.CRLF,
        },
      });

      const snap = synthSnapshot(project);

      expect(
        snap[".gitattributes"].trim()
          .startsWith(`# ~~ Generated by projen. To modify, edit .projenrc.js and run "npx projen".

* text=auto eol=crlf`)
      ).toBe(true);
    });
  });

  test("should add attributes to files", () => {
    withProjectDir((outdir) => {
      // The TestProject already contains a .gitattributes file
      const project = new TestProject({
        outdir,
      });

      project.gitattributes.addAttributes("*.txt", "text");
      project.gitattributes.addAttributes("*.md", "text", "markdown");

      const snap = synthSnapshot(project);

      const lines: string[] = snap[".gitattributes"]
        .split("\n")
        .map((line: string) => line.trim());

      expect(lines).toContain("*.md text markdown");
      expect(lines).toContain("*.txt text");
    });
  });

  test("should add a LFS pattern", () => {
    withProjectDir((outdir) => {
      // The TestProject already contains a .gitattributes file
      const project = new TestProject({
        outdir,
      });

      project.gitattributes.addLfsPattern("*.bin");

      const snap = synthSnapshot(project);

      const lines: string[] = snap[".gitattributes"]
        .split("\n")
        .map((line: string) => line.trim());

      expect(lines).toContain("*.bin filter=lfs diff=lfs merge=lfs -text");
    });
  });

  test("should have LFS patterns", () => {
    // The TestProject already contains a .gitattributes file
    const project = new TestProject();
    project.gitattributes.addLfsPattern("*.bin");

    expect(project.gitattributes.hasLfsPatterns).toBe(true);
  });

  test("should have default end of line character", () => {
    // The TestProject already contains a .gitattributes file
    const project = new TestProject();
    expect(project.gitattributes.endOfLine).toBe(EndOfLine.LF);
  });
});

describe("annotateGenerated", () => {
  test("uses normalized paths", () => {
    const project = new TestProject();
    project.annotateGenerated("\\some\\windows\\like\\path");

    const lines = synthSnapshot(project)[".gitattributes"].split("\n");

    expect(lines).toContain("/some/windows/like/path linguist-generated");
  });
});
