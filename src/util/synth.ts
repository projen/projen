import * as fs from "fs";
import * as os from "os";
import * as path from "path";
import * as JSONC from "comment-json";
import { CommentArray } from "comment-json";
import * as glob from "fast-glob";
import { JsonFile } from "../json";
import { Project } from "../project";

/**
 * Options for the Snapshot synthesis
 */
export interface SnapshotOptions {
  /**
   * Parse .json files as a JS object for improved inspection.
   * This will fail if the contents are invalid JSON.
   *
   * @default true parse .json files into an object
   */
  readonly parseJson?: boolean;
}

export interface SynthOutput {
  [filePath: string]: any;
}

/**
 * Creates a snapshot of the files generated by a project. Ignores any non-text
 * files so that the snapshots are human readable.
 */
export function synthSnapshot(
  project: Project,
  options: SnapshotOptions = {}
): SynthOutput {
  // defensive: verify that "outdir" is actually in a temporary directory
  if (
    !path.resolve(project.outdir).startsWith(os.tmpdir()) &&
    !project.outdir.includes("project-temp-dir")
  ) {
    throw new Error(
      "Trying to capture a snapshot of a project outside of tmpdir, which implies this test might corrupt an existing project"
    );
  }

  const synthed = Symbol.for("synthed");
  if (synthed in project) {
    throw new Error("duplicate synth()");
  }

  (project as any)[synthed] = true;

  const ENV_PROJEN_DISABLE_POST = process.env.PROJEN_DISABLE_POST;
  try {
    process.env.PROJEN_DISABLE_POST = "true";
    project.synth();
    const ignoreExts = ["png", "ico"];
    return directorySnapshot(project.outdir, {
      ...options,
      excludeGlobs: ignoreExts.map((ext) => `**/*.${ext}`),
      supportJsonComments: project.files.some(
        // At least one json file in project supports comments
        (file) => file instanceof JsonFile && file.supportsComments
      ),
    });
  } finally {
    fs.rmSync(project.outdir, { force: true, recursive: true });

    // values assigned to process.env.XYZ are automatically converted to strings
    if (ENV_PROJEN_DISABLE_POST === undefined) {
      delete process.env.PROJEN_DISABLE_POST;
    } else {
      process.env.PROJEN_DISABLE_POST = ENV_PROJEN_DISABLE_POST;
    }
  }
}

export interface DirectorySnapshotOptions extends SnapshotOptions {
  /**
   * Globs of files to exclude.
   * @default [] include all files
   */
  readonly excludeGlobs?: string[];

  /**
   * Only snapshot the names of files and not their contents.
   * The value for a path will be `true` if it exists.
   *
   * @default false include file content
   */
  readonly onlyFileNames?: boolean;

  /**
   * Parses files with different parser, supporting comments
   * inside .json files.
   * @default false
   */
  readonly supportJsonComments?: boolean;
}

function isJsonLikeFile(filePath: string): boolean {
  const file = filePath.toLowerCase();
  return (
    file.endsWith(".json") || file.endsWith(".json5") || file.endsWith(".jsonc")
  );
}

export function directorySnapshot(
  root: string,
  options: DirectorySnapshotOptions = {}
) {
  const output: SynthOutput = {};

  const files = glob.sync("**", {
    ignore: [".git/**", ...(options.excludeGlobs ?? [])],
    cwd: root,
    onlyFiles: true,
    followSymbolicLinks: false,
    dot: true,
  }); // returns relative file paths with POSIX separators

  const parseJson = options.parseJson ?? true;

  for (const file of files) {
    const filePath = path.join(root, file);

    let content;
    if (!options.onlyFileNames) {
      content = fs.readFileSync(filePath, "utf-8");
      if (parseJson && isJsonLikeFile(filePath)) {
        content = cleanCommentArrays(
          JSONC.parse(content, undefined, !options.supportJsonComments)
        );
      }
    } else {
      content = true;
    }

    output[file] = content;
  }

  return output;
}

/**
 * Converts type "CommentArray" back to regular JS "Array"
 * if there are no comments stored in it.
 * Prevents strict checks from failing.
 */
function cleanCommentArrays(obj: any): typeof obj {
  if (Array.isArray(obj) || isCommentArrayWithoutComments(obj)) {
    return Array.from(obj).map(cleanCommentArrays);
  }

  if (obj instanceof Object) {
    for (const p of Object.keys(obj)) {
      if (isCommentArrayWithoutComments(obj[p])) {
        obj[p] = Array.from(obj[p]).map(cleanCommentArrays);
      } else if (obj[p] instanceof Object) {
        obj[p] = cleanCommentArrays(obj[p]);
      }
    }
  }

  return obj;
}

/**
 * Checks if a "CommentArray" has no comments stored in it.
 */
function isCommentArrayWithoutComments(obj: any): boolean {
  return (
    obj instanceof CommentArray &&
    Object.getOwnPropertySymbols(obj).length === 0
  );
}
