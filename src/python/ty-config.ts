// ~~ Generated by projen. To modify, edit .projenrc.ts and run "node ./projen.js".
/**
 * @schema TyConfiguration
 */
export interface TyConfiguration {
  /**
   * Configures the type checking environment.
   *
   * @schema TyConfiguration#environment
   */
  readonly environment?: EnvironmentOptions;

  /**
   * Override configurations for specific file patterns.
   *
   * Each override specifies include/exclude patterns and rule configurations
   * that apply to matching files. Multiple overrides can match the same file,
   * with later overrides taking precedence.
   *
   * @schema TyConfiguration#overrides
   */
  readonly overrides?: OverrideOptions[];

  /**
   * Configures the enabled rules and their severity.
   *
   * See [the rules documentation](https://ty.dev/rules) for a list of all available rules.
   *
   * Valid severities are:
   *
   * * `ignore`: Disable the rule.
   * * `warn`: Enable the rule and create a warning diagnostic.
   * * `error`: Enable the rule and create an error diagnostic.
   * ty will exit with a non-zero code if any error diagnostics are emitted.
   *
   * @schema TyConfiguration#rules
   */
  readonly rules?: Rules;

  /**
   * @schema TyConfiguration#src
   */
  readonly src?: SrcOptions;

  /**
   * @schema TyConfiguration#terminal
   */
  readonly terminal?: TerminalOptions;
}

/**
 * Converts an object of type 'TyConfiguration' to JSON representation.
 * @internal
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TyConfiguration(obj: TyConfiguration | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'environment': toJson_EnvironmentOptions(obj.environment),
    'overrides': obj.overrides?.map(y => toJson_OverrideOptions(y)),
    'rules': toJson_Rules(obj.rules),
    'src': toJson_SrcOptions(obj.src),
    'terminal': toJson_TerminalOptions(obj.terminal),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema EnvironmentOptions
 */
export interface EnvironmentOptions {
  /**
   * User-provided paths that should take first priority in module resolution.
   *
   * This is an advanced option that should usually only be used for first-party or third-party
   * modules that are not installed into your Python environment in a conventional way.
   * Use the `python` option to specify the location of your Python environment.
   *
   * This option is similar to mypy's `MYPYPATH` environment variable and pyright's `stubPath`
   * configuration setting.
   *
   * @schema EnvironmentOptions#extra-paths
   */
  readonly extraPaths?: string[];

  /**
   * Path to your project's Python environment or interpreter.
   *
   * ty uses the `site-packages` directory of your project's Python environment
   * to resolve third-party (and, in some cases, first-party) imports in your code.
   *
   * If you're using a project management tool such as uv, you should not generally need
   * to specify this option, as commands such as `uv run` will set the `VIRTUAL_ENV`
   * environment variable to point to your project's virtual environment. ty can also infer
   * the location of your environment from an activated Conda environment, and will look for
   * a `.venv` directory in the project root if none of the above apply.
   *
   * Passing a path to a Python executable is supported, but passing a path to a dynamic executable
   * (such as a shim) is not currently supported.
   *
   * This option can be used to point to virtual or system Python environments.
   *
   * @schema EnvironmentOptions#python
   */
  readonly python?: string;

  /**
   * Specifies the target platform that will be used to analyze the source code.
   * If specified, ty will understand conditions based on comparisons with `sys.platform`, such
   * as are commonly found in typeshed to reflect the differing contents of the standard library across platforms.
   * If `all` is specified, ty will assume that the source code can run on any platform.
   *
   * If no platform is specified, ty will use the current platform:
   * - `win32` for Windows
   * - `darwin` for macOS
   * - `android` for Android
   * - `ios` for iOS
   * - `linux` for everything else
   *
   * @schema EnvironmentOptions#python-platform
   */
  readonly pythonPlatform?: any;

  /**
   * Specifies the version of Python that will be used to analyze the source code.
   * The version should be specified as a string in the format `M.m` where `M` is the major version
   * and `m` is the minor (e.g. `"3.0"` or `"3.6"`).
   * If a version is provided, ty will generate errors if the source code makes use of language features
   * that are not supported in that version.
   *
   * If a version is not specified, ty will try the following techniques in order of preference
   * to determine a value:
   * 1. Check for the `project.requires-python` setting in a `pyproject.toml` file
   * and use the minimum version from the specified range
   * 2. Check for an activated or configured Python environment
   * and attempt to infer the Python version of that environment
   * 3. Fall back to the default value (see below)
   *
   * For some language features, ty can also understand conditionals based on comparisons
   * with `sys.version_info`. These are commonly found in typeshed, for example,
   * to reflect the differing contents of the standard library across Python versions.
   *
   * @schema EnvironmentOptions#python-version
   */
  readonly pythonVersion?: any;

  /**
   * The root paths of the project, used for finding first-party modules.
   *
   * Accepts a list of directory paths searched in priority order (first has highest priority).
   *
   * If left unspecified, ty will try to detect common project layouts and initialize `root` accordingly:
   *
   * * if a `./src` directory exists, include `.` and `./src` in the first party search path (src layout or flat)
   * * if a `./<project-name>/<project-name>` directory exists, include `.` and `./<project-name>` in the first party search path
   * * otherwise, default to `.` (flat layout)
   *
   * Besides, if a `./python` or `./tests` directory exists and is not a package (i.e. it does not contain an `__init__.py` or `__init__.pyi` file),
   * it will also be included in the first party search path.
   *
   * @schema EnvironmentOptions#root
   */
  readonly root?: string[];

  /**
   * Optional path to a "typeshed" directory on disk for us to use for standard-library types.
   * If this is not provided, we will fallback to our vendored typeshed stubs for the stdlib,
   * bundled as a zip file in the binary
   *
   * @schema EnvironmentOptions#typeshed
   */
  readonly typeshed?: string;
}

/**
 * Converts an object of type 'EnvironmentOptions' to JSON representation.
 * @internal
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_EnvironmentOptions(obj: EnvironmentOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extra-paths': obj.extraPaths?.map(y => y),
    'python': obj.python,
    'python-platform': obj.pythonPlatform,
    'python-version': obj.pythonVersion,
    'root': obj.root?.map(y => y),
    'typeshed': obj.typeshed,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema OverrideOptions
 */
export interface OverrideOptions {
  /**
   * A list of file and directory patterns to exclude from this override.
   *
   * Patterns follow a syntax similar to `.gitignore`.
   * Exclude patterns take precedence over include patterns within the same override.
   *
   * If not specified, defaults to `[]` (excludes no files).
   *
   * @schema OverrideOptions#exclude
   */
  readonly exclude?: string[];

  /**
   * A list of file and directory patterns to include for this override.
   *
   * The `include` option follows a similar syntax to `.gitignore` but reversed:
   * Including a file or directory will make it so that it (and its contents)
   * are affected by this override.
   *
   * If not specified, defaults to `["**"]` (matches all files).
   *
   * @schema OverrideOptions#include
   */
  readonly include?: string[];

  /**
   * Rule overrides for files matching the include/exclude patterns.
   *
   * These rules will be merged with the global rules, with override rules
   * taking precedence for matching files. You can set rules to different
   * severity levels or disable them entirely.
   *
   * @schema OverrideOptions#rules
   */
  readonly rules?: Rules;
}

/**
 * Converts an object of type 'OverrideOptions' to JSON representation.
 * @internal
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_OverrideOptions(obj: OverrideOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclude': obj.exclude?.map(y => y),
    'include': obj.include?.map(y => y),
    'rules': toJson_Rules(obj.rules),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema Rules
 */
export interface Rules {
  /**
   * ## What it does
   * Checks for protocol classes with members that will lead to ambiguous interfaces.
   *
   * ## Why is this bad?
   * Assigning to an undeclared variable in a protocol class leads to an ambiguous
   * interface which may lead to the type checker inferring unexpected things. It's
   * recommended to ensure that all members of a protocol class are explicitly declared.
   *
   * ## Examples
   *
   * ```py
   * from typing import Protocol
   *
   * class BaseProto(Protocol):
   * a: int                               # fine (explicitly declared as `int`)
   * def method_member(self) -> int: ...  # fine: a method definition using `def` is considered a declaration
   * c = "some variable"                  # error: no explicit declaration, leading to ambiguity
   * b = method_member                    # error: no explicit declaration, leading to ambiguity
   *
   * # error: this creates implicit assignments of `d` and `e` in the protocol class body.
   * # Were they really meant to be considered protocol members?
   * for d, e in enumerate(range(42)):
   * pass
   *
   * class SubProto(BaseProto, Protocol):
   * a = 42  # fine (declared in superclass)
   * ```
   *
   * @schema Rules#ambiguous-protocol-member
   */
  readonly ambiguousProtocolMember?: string;

  /**
   * ## What it does
   * Checks for byte-strings in type annotation positions.
   *
   * ## Why is this bad?
   * Static analysis tools like ty can't analyze type annotations that use byte-string notation.
   *
   * ## Examples
   * ```python
   * def test(): -> b"int":
   * ...
   * ```
   *
   * Use instead:
   * ```python
   * def test(): -> "int":
   * ...
   * ```
   *
   * @schema Rules#byte-string-type-annotation
   */
  readonly byteStringTypeAnnotation?: string;

  /**
   * ## What it does
   * Checks for calls to non-callable objects.
   *
   * ## Why is this bad?
   * Calling a non-callable object will raise a `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * 4()  # TypeError: 'int' object is not callable
   * ```
   *
   * @schema Rules#call-non-callable
   */
  readonly callNonCallable?: string;

  /**
   * ## What it does
   * Checks whether an argument is used as both a value and a type form in a call.
   *
   * ## Why is this bad?
   * Such calls have confusing semantics and often indicate a logic error.
   *
   * ## Examples
   * ```python
   * from typing import reveal_type
   * from ty_extensions import is_singleton
   *
   * if flag:
   * f = repr  # Expects a value
   * else:
   * f = is_singleton  # Expects a type form
   *
   * f(int)  # error
   * ```
   *
   * @schema Rules#conflicting-argument-forms
   */
  readonly conflictingArgumentForms?: string;

  /**
   * ## What it does
   * Checks whether a variable has been declared as two conflicting types.
   *
   * ## Why is this bad
   * A variable with two conflicting declarations likely indicates a mistake.
   * Moreover, it could lead to incorrect or ill-defined type inference for
   * other code that relies on these variables.
   *
   * ## Examples
   * ```python
   * if b:
   * a: int
   * else:
   * a: str
   *
   * a = 1
   * ```
   *
   * @schema Rules#conflicting-declarations
   */
  readonly conflictingDeclarations?: string;

  /**
   * ## What it does
   * Checks for class definitions where the metaclass of the class
   * being created would not be a subclass of the metaclasses of
   * all the class's bases.
   *
   * ## Why is it bad?
   * Such a class definition raises a `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * class M1(type): ...
   * class M2(type): ...
   * class A(metaclass=M1): ...
   * class B(metaclass=M2): ...
   *
   * # TypeError: metaclass conflict
   * class C(A, B): ...
   * ```
   *
   * @schema Rules#conflicting-metaclass
   */
  readonly conflictingMetaclass?: string;

  /**
   * ## What it does
   * Checks for class definitions in stub files that inherit
   * (directly or indirectly) from themselves.
   *
   * ## Why is it bad?
   * Although forward references are natively supported in stub files,
   * inheritance cycles are still disallowed, as it is impossible to
   * resolve a consistent [method resolution order] for a class that
   * inherits from itself.
   *
   * ## Examples
   * ```python
   * # foo.pyi
   * class A(B): ...
   * class B(A): ...
   * ```
   *
   * [method resolution order]: https://docs.python.org/3/glossary.html#term-method-resolution-order
   *
   * @schema Rules#cyclic-class-definition
   */
  readonly cyclicClassDefinition?: string;

  /**
   * ## What it does
   * Checks for uses of deprecated items
   *
   * ## Why is this bad?
   * Deprecated items should no longer be used.
   *
   * ## Examples
   * ```python
   * @warnings.deprecated("use new_func instead")
   * def old_func(): ...
   *
   * old_func()  # emits [deprecated] diagnostic
   * ```
   *
   * @schema Rules#deprecated
   */
  readonly deprecated?: string;

  /**
   * ## What it does
   * It detects division by zero.
   *
   * ## Why is this bad?
   * Dividing by zero raises a `ZeroDivisionError` at runtime.
   *
   * ## Examples
   * ```python
   * 5 / 0
   * ```
   *
   * @schema Rules#division-by-zero
   */
  readonly divisionByZero?: string;

  /**
   * ## What it does
   * Checks for class definitions with duplicate bases.
   *
   * ## Why is this bad?
   * Class definitions with duplicate bases raise `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * class A: ...
   *
   * # TypeError: duplicate base class
   * class B(A, A): ...
   * ```
   *
   * @schema Rules#duplicate-base
   */
  readonly duplicateBase?: string;

  /**
   * ## What it does
   * Checks for dataclass definitions with more than one field
   * annotated with `KW_ONLY`.
   *
   * ## Why is this bad?
   * `dataclasses.KW_ONLY` is a special marker used to
   * emulate the `*` syntax in normal signatures.
   * It can only be used once per dataclass.
   *
   * Attempting to annotate two different fields with
   * it will lead to a runtime error.
   *
   * ## Examples
   * ```python
   * from dataclasses import dataclass, KW_ONLY
   *
   * @dataclass
   * class A:  # Crash at runtime
   * b: int
   * _1: KW_ONLY
   * c: str
   * _2: KW_ONLY
   * d: bytes
   * ```
   *
   * @schema Rules#duplicate-kw-only
   */
  readonly duplicateKwOnly?: string;

  /**
   * TODO #14889
   *
   * @schema Rules#escape-character-in-forward-annotation
   */
  readonly escapeCharacterInForwardAnnotation?: string;

  /**
   * ## What it does
   * Checks for f-strings in type annotation positions.
   *
   * ## Why is this bad?
   * Static analysis tools like ty can't analyze type annotations that use f-string notation.
   *
   * ## Examples
   * ```python
   * def test(): -> f"int":
   * ...
   * ```
   *
   * Use instead:
   * ```python
   * def test(): -> "int":
   * ...
   * ```
   *
   * @schema Rules#fstring-type-annotation
   */
  readonly fstringTypeAnnotation?: string;

  /**
   * ## What it does
   * Checks for `ty: ignore[code]` where `code` isn't a known lint rule.
   *
   * ## Why is this bad?
   * A `ty: ignore[code]` directive with a `code` that doesn't match
   * any known rule will not suppress any type errors, and is probably a mistake.
   *
   * ## Examples
   * ```py
   * a = 20 / 0  # ty: ignore[division-by-zer]
   * ```
   *
   * Use instead:
   *
   * ```py
   * a = 20 / 0  # ty: ignore[division-by-zero]
   * ```
   *
   * @schema Rules#ignore-comment-unknown-rule
   */
  readonly ignoreCommentUnknownRule?: string;

  /**
   * ## What it does
   * Checks for implicit concatenated strings in type annotation positions.
   *
   * ## Why is this bad?
   * Static analysis tools like ty can't analyze type annotations that use implicit concatenated strings.
   *
   * ## Examples
   * ```python
   * def test(): -> "Literal[" "5" "]":
   * ...
   * ```
   *
   * Use instead:
   * ```python
   * def test(): -> "Literal[5]":
   * ...
   * ```
   *
   * @schema Rules#implicit-concatenated-string-type-annotation
   */
  readonly implicitConcatenatedStringTypeAnnotation?: string;

  /**
   * ## What it does
   * Checks for classes with an inconsistent [method resolution order] (MRO).
   *
   * ## Why is this bad?
   * Classes with an inconsistent MRO will raise a `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * class A: ...
   * class B(A): ...
   *
   * # TypeError: Cannot create a consistent method resolution order
   * class C(A, B): ...
   * ```
   *
   * [method resolution order]: https://docs.python.org/3/glossary.html#term-method-resolution-order
   *
   * @schema Rules#inconsistent-mro
   */
  readonly inconsistentMro?: string;

  /**
   * ## What it does
   * Checks for attempts to use an out of bounds index to get an item from
   * a container.
   *
   * ## Why is this bad?
   * Using an out of bounds index will raise an `IndexError` at runtime.
   *
   * ## Examples
   * ```python
   * t = (0, 1, 2)
   * t[3]  # IndexError: tuple index out of range
   * ```
   *
   * @schema Rules#index-out-of-bounds
   */
  readonly indexOutOfBounds?: string;

  /**
   * ## What it does
   * Checks for classes definitions which will fail at runtime due to
   * "instance memory layout conflicts".
   *
   * This error is usually caused by attempting to combine multiple classes
   * that define non-empty `__slots__` in a class's [Method Resolution Order]
   * (MRO), or by attempting to combine multiple builtin classes in a class's
   * MRO.
   *
   * ## Why is this bad?
   * Inheriting from bases with conflicting instance memory layouts
   * will lead to a `TypeError` at runtime.
   *
   * An instance memory layout conflict occurs when CPython cannot determine
   * the memory layout instances of a class should have, because the instance
   * memory layout of one of its bases conflicts with the instance memory layout
   * of one or more of its other bases.
   *
   * For example, if a Python class defines non-empty `__slots__`, this will
   * impact the memory layout of instances of that class. Multiple inheritance
   * from more than one different class defining non-empty `__slots__` is not
   * allowed:
   *
   * ```python
   * class A:
   * __slots__ = ("a", "b")
   *
   * class B:
   * __slots__ = ("a", "b")  # Even if the values are the same
   *
   * # TypeError: multiple bases have instance lay-out conflict
   * class C(A, B): ...
   * ```
   *
   * An instance layout conflict can also be caused by attempting to use
   * multiple inheritance with two builtin classes, due to the way that these
   * classes are implemented in a CPython C extension:
   *
   * ```python
   * class A(int, float): ...  # TypeError: multiple bases have instance lay-out conflict
   * ```
   *
   * Note that pure-Python classes with no `__slots__`, or pure-Python classes
   * with empty `__slots__`, are always compatible:
   *
   * ```python
   * class A: ...
   * class B:
   * __slots__ = ()
   * class C:
   * __slots__ = ("a", "b")
   *
   * # fine
   * class D(A, B, C): ...
   * ```
   *
   * ## Known problems
   * Classes that have "dynamic" definitions of `__slots__` (definitions do not consist
   * of string literals, or tuples of string literals) are not currently considered disjoint
   * bases by ty.
   *
   * Additionally, this check is not exhaustive: many C extensions (including several in
   * the standard library) define classes that use extended memory layouts and thus cannot
   * coexist in a single MRO. Since it is currently not possible to represent this fact in
   * stub files, having a full knowledge of these classes is also impossible. When it comes
   * to classes that do not define `__slots__` at the Python level, therefore, ty, currently
   * only hard-codes a number of cases where it knows that a class will produce instances with
   * an atypical memory layout.
   *
   * ## Further reading
   * - [CPython documentation: `__slots__`](https://docs.python.org/3/reference/datamodel.html#slots)
   * - [CPython documentation: Method Resolution Order](https://docs.python.org/3/glossary.html#term-method-resolution-order)
   *
   * [Method Resolution Order]: https://docs.python.org/3/glossary.html#term-method-resolution-order
   *
   * @schema Rules#instance-layout-conflict
   */
  readonly instanceLayoutConflict?: string;

  /**
   * ## What it does
   * Detects call arguments whose type is not assignable to the corresponding typed parameter.
   *
   * ## Why is this bad?
   * Passing an argument of a type the function (or callable object) does not accept violates
   * the expectations of the function author and may cause unexpected runtime errors within the
   * body of the function.
   *
   * ## Examples
   * ```python
   * def func(x: int): ...
   * func("foo")  # error: [invalid-argument-type]
   * ```
   *
   * @schema Rules#invalid-argument-type
   */
  readonly invalidArgumentType?: string;

  /**
   * ## What it does
   * Checks for assignments where the type of the value
   * is not [assignable to] the type of the assignee.
   *
   * ## Why is this bad?
   * Such assignments break the rules of the type system and
   * weaken a type checker's ability to accurately reason about your code.
   *
   * ## Examples
   * ```python
   * a: int = ''
   * ```
   *
   * [assignable to]: https://typing.python.org/en/latest/spec/glossary.html#term-assignable
   *
   * @schema Rules#invalid-assignment
   */
  readonly invalidAssignment?: string;

  /**
   * ## What it does
   * Checks for assignments to class variables from instances
   * and assignments to instance variables from its class.
   *
   * ## Why is this bad?
   * Incorrect assignments break the rules of the type system and
   * weaken a type checker's ability to accurately reason about your code.
   *
   * ## Examples
   * ```python
   * class C:
   * class_var: ClassVar[int] = 1
   * instance_var: int
   *
   * C.class_var = 3  # okay
   * C().class_var = 3  # error: Cannot assign to class variable
   *
   * C().instance_var = 3  # okay
   * C.instance_var = 3  # error: Cannot assign to instance variable
   * ```
   *
   * @schema Rules#invalid-attribute-access
   */
  readonly invalidAttributeAccess?: string;

  /**
   * ## What it does
   * Checks for `await` being used with types that are not [Awaitable].
   *
   * ## Why is this bad?
   * Such expressions will lead to `TypeError` being raised at runtime.
   *
   * ## Examples
   * ```python
   * import asyncio
   *
   * class InvalidAwait:
   * def __await__(self) -> int:
   * return 5
   *
   * async def main() -> None:
   * await InvalidAwait()  # error: [invalid-await]
   * await 42  # error: [invalid-await]
   *
   * asyncio.run(main())
   * ```
   *
   * [Awaitable]: https://docs.python.org/3/library/collections.abc.html#collections.abc.Awaitable
   *
   * @schema Rules#invalid-await
   */
  readonly invalidAwait?: string;

  /**
   * ## What it does
   * Checks for class definitions that have bases which are not instances of `type`.
   *
   * ## Why is this bad?
   * Class definitions with bases like this will lead to `TypeError` being raised at runtime.
   *
   * ## Examples
   * ```python
   * class A(42): ...  # error: [invalid-base]
   * ```
   *
   * @schema Rules#invalid-base
   */
  readonly invalidBase?: string;

  /**
   * ## What it does
   * Checks for expressions used in `with` statements
   * that do not implement the context manager protocol.
   *
   * ## Why is this bad?
   * Such a statement will raise `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * # TypeError: 'int' object does not support the context manager protocol
   * with 1:
   * print(2)
   * ```
   *
   * @schema Rules#invalid-context-manager
   */
  readonly invalidContextManager?: string;

  /**
   * ## What it does
   * Checks for declarations where the inferred type of an existing symbol
   * is not [assignable to] its post-hoc declared type.
   *
   * ## Why is this bad?
   * Such declarations break the rules of the type system and
   * weaken a type checker's ability to accurately reason about your code.
   *
   * ## Examples
   * ```python
   * a = 1
   * a: str
   * ```
   *
   * [assignable to]: https://typing.python.org/en/latest/spec/glossary.html#term-assignable
   *
   * @schema Rules#invalid-declaration
   */
  readonly invalidDeclaration?: string;

  /**
   * ## What it does
   * Checks for exception handlers that catch non-exception classes.
   *
   * ## Why is this bad?
   * Catching classes that do not inherit from `BaseException` will raise a `TypeError` at runtime.
   *
   * ## Example
   * ```python
   * try:
   * 1 / 0
   * except 1:
   * ...
   * ```
   *
   * Use instead:
   * ```python
   * try:
   * 1 / 0
   * except ZeroDivisionError:
   * ...
   * ```
   *
   * ## References
   * - [Python documentation: except clause](https://docs.python.org/3/reference/compound_stmts.html#except-clause)
   * - [Python documentation: Built-in Exceptions](https://docs.python.org/3/library/exceptions.html#built-in-exceptions)
   *
   * ## Ruff rule
   * This rule corresponds to Ruff's [`except-with-non-exception-classes` (`B030`)](https://docs.astral.sh/ruff/rules/except-with-non-exception-classes)
   *
   * @schema Rules#invalid-exception-caught
   */
  readonly invalidExceptionCaught?: string;

  /**
   * ## What it does
   * Checks for the creation of invalid generic classes
   *
   * ## Why is this bad?
   * There are several requirements that you must follow when defining a generic class.
   *
   * ## Examples
   * ```python
   * from typing import Generic, TypeVar
   *
   * T = TypeVar("T")  # okay
   *
   * # error: class uses both PEP-695 syntax and legacy syntax
   * class C[U](Generic[T]): ...
   * ```
   *
   * ## References
   * - [Typing spec: Generics](https://typing.python.org/en/latest/spec/generics.html#introduction)
   *
   * @schema Rules#invalid-generic-class
   */
  readonly invalidGenericClass?: string;

  /**
   * ## What it does
   * Checks for `type: ignore` and `ty: ignore` comments that are syntactically incorrect.
   *
   * ## Why is this bad?
   * A syntactically incorrect ignore comment is probably a mistake and is useless.
   *
   * ## Examples
   * ```py
   * a = 20 / 0  # type: ignoree
   * ```
   *
   * Use instead:
   *
   * ```py
   * a = 20 / 0  # type: ignore
   * ```
   *
   * @schema Rules#invalid-ignore-comment
   */
  readonly invalidIgnoreComment?: string;

  /**
   * ## What it does
   * Checks for subscript accesses with invalid keys and `TypedDict` construction with an
   * unknown key.
   *
   * ## Why is this bad?
   * Subscripting with an invalid key will raise a `KeyError` at runtime.
   *
   * Creating a `TypedDict` with an unknown key is likely a mistake; if the `TypedDict` is
   * `closed=true` it also violates the expectations of the type.
   *
   * ## Examples
   * ```python
   * from typing import TypedDict
   *
   * class Person(TypedDict):
   * name: str
   * age: int
   *
   * alice = Person(name="Alice", age=30)
   * alice["height"]  # KeyError: 'height'
   *
   * bob: Person = { "name": "Bob", "age": 30 }  # typo!
   *
   * carol = Person(name="Carol", age=25)  # typo!
   * ```
   *
   * @schema Rules#invalid-key
   */
  readonly invalidKey?: string;

  /**
   * ## What it does
   * Checks for the creation of invalid legacy `TypeVar`s
   *
   * ## Why is this bad?
   * There are several requirements that you must follow when creating a legacy `TypeVar`.
   *
   * ## Examples
   * ```python
   * from typing import TypeVar
   *
   * T = TypeVar("T")  # okay
   * Q = TypeVar("S")  # error: TypeVar name must match the variable it's assigned to
   * T = TypeVar("T")  # error: TypeVars should not be redefined
   *
   * # error: TypeVar must be immediately assigned to a variable
   * def f(t: TypeVar("U")): ...
   * ```
   *
   * ## References
   * - [Typing spec: Generics](https://typing.python.org/en/latest/spec/generics.html#introduction)
   *
   * @schema Rules#invalid-legacy-type-variable
   */
  readonly invalidLegacyTypeVariable?: string;

  /**
   * ## What it does
   * Checks for arguments to `metaclass=` that are invalid.
   *
   * ## Why is this bad?
   * Python allows arbitrary expressions to be used as the argument to `metaclass=`.
   * These expressions, however, need to be callable and accept the same arguments
   * as `type.__new__`.
   *
   * ## Example
   *
   * ```python
   * def f(): ...
   *
   * # TypeError: f() takes 0 positional arguments but 3 were given
   * class B(metaclass=f): ...
   * ```
   *
   * ## References
   * - [Python documentation: Metaclasses](https://docs.python.org/3/reference/datamodel.html#metaclasses)
   *
   * @schema Rules#invalid-metaclass
   */
  readonly invalidMetaclass?: string;

  /**
   * ## What it does
   * Checks for invalidly defined `NamedTuple` classes.
   *
   * ## Why is this bad?
   * An invalidly defined `NamedTuple` class may lead to the type checker
   * drawing incorrect conclusions. It may also lead to `TypeError`s at runtime.
   *
   * ## Examples
   * A class definition cannot combine `NamedTuple` with other base classes
   * in multiple inheritance; doing so raises a `TypeError` at runtime. The sole
   * exception to this rule is `Generic[]`, which can be used alongside `NamedTuple`
   * in a class's bases list.
   *
   * ```pycon
   * >>> from typing import NamedTuple
   * >>> class Foo(NamedTuple, object): ...
   * TypeError: can only inherit from a NamedTuple type and Generic
   * ```
   *
   * @schema Rules#invalid-named-tuple
   */
  readonly invalidNamedTuple?: string;

  /**
   * ## What it does
   * Checks for the creation of invalid `NewType`s
   *
   * ## Why is this bad?
   * There are several requirements that you must follow when creating a `NewType`.
   *
   * ## Examples
   * ```python
   * from typing import NewType
   *
   * def get_name() -> str: ...
   *
   * Foo = NewType("Foo", int)        # okay
   * Bar = NewType(get_name(), int)   # error: The first argument to `NewType` must be a string literal
   * Baz = NewType("Baz", int | str)  # error: invalid base for `typing.NewType`
   * ```
   *
   * @schema Rules#invalid-newtype
   */
  readonly invalidNewtype?: string;

  /**
   * ## What it does
   * Checks for various invalid `@overload` usages.
   *
   * ## Why is this bad?
   * The `@overload` decorator is used to define functions and methods that accepts different
   * combinations of arguments and return different types based on the arguments passed. This is
   * mainly beneficial for type checkers. But, if the `@overload` usage is invalid, the type
   * checker may not be able to provide correct type information.
   *
   * ## Example
   *
   * Defining only one overload:
   *
   * ```py
   * from typing import overload
   *
   * @overload
   * def foo(x: int) -> int: ...
   * def foo(x: int | None) -> int | None:
   * return x
   * ```
   *
   * Or, not providing an implementation for the overloaded definition:
   *
   * ```py
   * from typing import overload
   *
   * @overload
   * def foo() -> None: ...
   * @overload
   * def foo(x: int) -> int: ...
   * ```
   *
   * ## References
   * - [Python documentation: `@overload`](https://docs.python.org/3/library/typing.html#typing.overload)
   *
   * @schema Rules#invalid-overload
   */
  readonly invalidOverload?: string;

  /**
   * ## What it does
   * Checks for default values that can't be
   * assigned to the parameter's annotated type.
   *
   * ## Why is this bad?
   * This breaks the rules of the type system and
   * weakens a type checker's ability to accurately reason about your code.
   *
   * ## Examples
   * ```python
   * def f(a: int = ''): ...
   * ```
   *
   * @schema Rules#invalid-parameter-default
   */
  readonly invalidParameterDefault?: string;

  /**
   * ## What it does
   * Checks for the creation of invalid `ParamSpec`s
   *
   * ## Why is this bad?
   * There are several requirements that you must follow when creating a `ParamSpec`.
   *
   * ## Examples
   * ```python
   * from typing import ParamSpec
   *
   * P1 = ParamSpec("P1")  # okay
   * P2 = ParamSpec("S2")  # error: ParamSpec name must match the variable it's assigned to
   * ```
   *
   * ## References
   * - [Typing spec: ParamSpec](https://typing.python.org/en/latest/spec/generics.html#paramspec)
   *
   * @schema Rules#invalid-paramspec
   */
  readonly invalidParamspec?: string;

  /**
   * ## What it does
   * Checks for protocol classes that will raise `TypeError` at runtime.
   *
   * ## Why is this bad?
   * An invalidly defined protocol class may lead to the type checker inferring
   * unexpected things. It may also lead to `TypeError`s at runtime.
   *
   * ## Examples
   * A `Protocol` class cannot inherit from a non-`Protocol` class;
   * this raises a `TypeError` at runtime:
   *
   * ```pycon
   * >>> from typing import Protocol
   * >>> class Foo(int, Protocol): ...
   * ...
   * Traceback (most recent call last):
   * File "<python-input-1>", line 1, in <module>
   * class Foo(int, Protocol): ...
   * TypeError: Protocols can only inherit from other protocols, got <class 'int'>
   * ```
   *
   * @schema Rules#invalid-protocol
   */
  readonly invalidProtocol?: string;

  /**
   * Checks for `raise` statements that raise non-exceptions or use invalid
   * causes for their raised exceptions.
   *
   * ## Why is this bad?
   * Only subclasses or instances of `BaseException` can be raised.
   * For an exception's cause, the same rules apply, except that `None` is also
   * permitted. Violating these rules results in a `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * def f():
   * try:
   * something()
   * except NameError:
   * raise "oops!" from f
   *
   * def g():
   * raise NotImplemented from 42
   * ```
   *
   * Use instead:
   * ```python
   * def f():
   * try:
   * something()
   * except NameError as e:
   * raise RuntimeError("oops!") from e
   *
   * def g():
   * raise NotImplementedError from None
   * ```
   *
   * ## References
   * - [Python documentation: The `raise` statement](https://docs.python.org/3/reference/simple_stmts.html#raise)
   * - [Python documentation: Built-in Exceptions](https://docs.python.org/3/library/exceptions.html#built-in-exceptions)
   *
   * @schema Rules#invalid-raise
   */
  readonly invalidRaise?: string;

  /**
   * ## What it does
   * Detects returned values that can't be assigned to the function's annotated return type.
   *
   * ## Why is this bad?
   * Returning an object of a type incompatible with the annotated return type may cause confusion to the user calling the function.
   *
   * ## Examples
   * ```python
   * def func() -> int:
   * return "a"  # error: [invalid-return-type]
   * ```
   *
   * @schema Rules#invalid-return-type
   */
  readonly invalidReturnType?: string;

  /**
   * ## What it does
   * Detects `super()` calls where:
   * - the first argument is not a valid class literal, or
   * - the second argument is not an instance or subclass of the first argument.
   *
   * ## Why is this bad?
   * `super(type, obj)` expects:
   * - the first argument to be a class,
   * - and the second argument to satisfy one of the following:
   * - `isinstance(obj, type)` is `True`
   * - `issubclass(obj, type)` is `True`
   *
   * Violating this relationship will raise a `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * class A:
   * ...
   * class B(A):
   * ...
   *
   * super(A, B())  # it's okay! `A` satisfies `isinstance(B(), A)`
   *
   * super(A(), B()) # error: `A()` is not a class
   *
   * super(B, A())  # error: `A()` does not satisfy `isinstance(A(), B)`
   * super(B, A)  # error: `A` does not satisfy `issubclass(A, B)`
   * ```
   *
   * ## References
   * - [Python documentation: super()](https://docs.python.org/3/library/functions.html#super)
   *
   * @schema Rules#invalid-super-argument
   */
  readonly invalidSuperArgument?: string;

  /**
   * TODO #14889
   *
   * @schema Rules#invalid-syntax-in-forward-annotation
   */
  readonly invalidSyntaxInForwardAnnotation?: string;

  /**
   * ## What it does
   * Checks for the creation of invalid `TypeAliasType`s
   *
   * ## Why is this bad?
   * There are several requirements that you must follow when creating a `TypeAliasType`.
   *
   * ## Examples
   * ```python
   * from typing import TypeAliasType
   *
   * IntOrStr = TypeAliasType("IntOrStr", int | str)  # okay
   * NewAlias = TypeAliasType(get_name(), int)        # error: TypeAliasType name must be a string literal
   * ```
   *
   * @schema Rules#invalid-type-alias-type
   */
  readonly invalidTypeAliasType?: string;

  /**
   * ## What it does
   * Checks for a value other than `False` assigned to the `TYPE_CHECKING` variable, or an
   * annotation not assignable from `bool`.
   *
   * ## Why is this bad?
   * The name `TYPE_CHECKING` is reserved for a flag that can be used to provide conditional
   * code seen only by the type checker, and not at runtime. Normally this flag is imported from
   * `typing` or `typing_extensions`, but it can also be defined locally. If defined locally, it
   * must be assigned the value `False` at runtime; the type checker will consider its value to
   * be `True`. If annotated, it must be annotated as a type that can accept `bool` values.
   *
   * ## Examples
   * ```python
   * TYPE_CHECKING: str
   * TYPE_CHECKING = ''
   * ```
   *
   * @schema Rules#invalid-type-checking-constant
   */
  readonly invalidTypeCheckingConstant?: string;

  /**
   * ## What it does
   * Checks for expressions that are used as [type expressions]
   * but cannot validly be interpreted as such.
   *
   * ## Why is this bad?
   * Such expressions cannot be understood by ty.
   * In some cases, they might raise errors at runtime.
   *
   * ## Examples
   * ```python
   * from typing import Annotated
   *
   * a: type[1]  # `1` is not a type
   * b: Annotated[int]  # `Annotated` expects at least two arguments
   * ```
   * [type expressions]: https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions
   *
   * @schema Rules#invalid-type-form
   */
  readonly invalidTypeForm?: string;

  /**
   * ## What it does
   * Checks for type guard function calls without a valid target.
   *
   * ## Why is this bad?
   * The first non-keyword non-variadic argument to a type guard function
   * is its target and must map to a symbol.
   *
   * Starred (`is_str(*a)`), literal (`is_str(42)`) and other non-symbol-like
   * expressions are invalid as narrowing targets.
   *
   * ## Examples
   * ```python
   * from typing import TypeIs
   *
   * def f(v: object) -> TypeIs[int]: ...
   *
   * f()  # Error
   * f(*a)  # Error
   * f(10)  # Error
   * ```
   *
   * @schema Rules#invalid-type-guard-call
   */
  readonly invalidTypeGuardCall?: string;

  /**
   * ## What it does
   * Checks for type guard functions without
   * a first non-self-like non-keyword-only non-variadic parameter.
   *
   * ## Why is this bad?
   * Type narrowing functions must accept at least one positional argument
   * (non-static methods must accept another in addition to `self`/`cls`).
   *
   * Extra parameters/arguments are allowed but do not affect narrowing.
   *
   * ## Examples
   * ```python
   * from typing import TypeIs
   *
   * def f() -> TypeIs[int]: ...  # Error, no parameter
   * def f(*, v: object) -> TypeIs[int]: ...  # Error, no positional arguments allowed
   * def f(*args: object) -> TypeIs[int]: ... # Error, expect variadic arguments
   * class C:
   * def f(self) -> TypeIs[int]: ...  # Error, only positional argument expected is `self`
   * ```
   *
   * @schema Rules#invalid-type-guard-definition
   */
  readonly invalidTypeGuardDefinition?: string;

  /**
   * ## What it does
   * Checks for constrained [type variables] with only one constraint.
   *
   * ## Why is this bad?
   * A constrained type variable must have at least two constraints.
   *
   * ## Examples
   * ```python
   * from typing import TypeVar
   *
   * T = TypeVar('T', str)  # invalid constrained TypeVar
   * ```
   *
   * Use instead:
   * ```python
   * T = TypeVar('T', str, int)  # valid constrained TypeVar
   * # or
   * T = TypeVar('T', bound=str)  # valid bound TypeVar
   * ```
   *
   * [type variables]: https://docs.python.org/3/library/typing.html#typing.TypeVar
   *
   * @schema Rules#invalid-type-variable-constraints
   */
  readonly invalidTypeVariableConstraints?: string;

  /**
   * ## What it does
   * Checks for missing required arguments in a call.
   *
   * ## Why is this bad?
   * Failing to provide a required argument will raise a `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * def func(x: int): ...
   * func()  # TypeError: func() missing 1 required positional argument: 'x'
   * ```
   *
   * @schema Rules#missing-argument
   */
  readonly missingArgument?: string;

  /**
   * ## What it does
   * Detects missing required keys in `TypedDict` constructor calls.
   *
   * ## Why is this bad?
   * `TypedDict` requires all non-optional keys to be provided during construction.
   * Missing items can lead to a `KeyError` at runtime.
   *
   * ## Example
   * ```python
   * from typing import TypedDict
   *
   * class Person(TypedDict):
   * name: str
   * age: int
   *
   * alice: Person = {"name": "Alice"}  # missing required key 'age'
   *
   * alice["age"]  # KeyError
   * ```
   *
   * @schema Rules#missing-typed-dict-key
   */
  readonly missingTypedDictKey?: string;

  /**
   * ## What it does
   * Checks for calls to an overloaded function that do not match any of the overloads.
   *
   * ## Why is this bad?
   * Failing to provide the correct arguments to one of the overloads will raise a `TypeError`
   * at runtime.
   *
   * ## Examples
   * ```python
   * @overload
   * def func(x: int): ...
   * @overload
   * def func(x: bool): ...
   * func("string")  # error: [no-matching-overload]
   * ```
   *
   * @schema Rules#no-matching-overload
   */
  readonly noMatchingOverload?: string;

  /**
   * ## What it does
   * Checks for subscripting objects that do not support subscripting.
   *
   * ## Why is this bad?
   * Subscripting an object that does not support it will raise a `TypeError` at runtime.
   *
   * ## Examples
   * ```python
   * 4[1]  # TypeError: 'int' object is not subscriptable
   * ```
   *
   * @schema Rules#non-subscriptable
   */
  readonly nonSubscriptable?: string;

  /**
   * ## What it does
   * Checks for objects that are not iterable but are used in a context that requires them to be.
   *
   * ## Why is this bad?
   * Iterating over an object that is not iterable will raise a `TypeError` at runtime.
   *
   * ## Examples
   *
   * ```python
   * for i in 34:  # TypeError: 'int' object is not iterable
   * pass
   * ```
   *
   * @schema Rules#not-iterable
   */
  readonly notIterable?: string;

  /**
   * ## What it does
   * Checks for calls which provide more than one argument for a single parameter.
   *
   * ## Why is this bad?
   * Providing multiple values for a single parameter will raise a `TypeError` at runtime.
   *
   * ## Examples
   *
   * ```python
   * def f(x: int) -> int: ...
   *
   * f(1, x=2)  # Error raised here
   * ```
   *
   * @schema Rules#parameter-already-assigned
   */
  readonly parameterAlreadyAssigned?: string;

  /**
   * ## What it does
   * Checks for keyword arguments in calls that match positional-only parameters of the callable.
   *
   * ## Why is this bad?
   * Providing a positional-only parameter as a keyword argument will raise `TypeError` at runtime.
   *
   * ## Example
   *
   * ```python
   * def f(x: int, /) -> int: ...
   *
   * f(x=1)  # Error raised here
   * ```
   *
   * @schema Rules#positional-only-parameter-as-kwarg
   */
  readonly positionalOnlyParameterAsKwarg?: string;

  /**
   * ## What it does
   * Checks for possibly missing attributes.
   *
   * ## Why is this bad?
   * Attempting to access a missing attribute will raise an `AttributeError` at runtime.
   *
   * ## Examples
   * ```python
   * class A:
   * if b:
   * c = 0
   *
   * A.c  # AttributeError: type object 'A' has no attribute 'c'
   * ```
   *
   * @schema Rules#possibly-missing-attribute
   */
  readonly possiblyMissingAttribute?: string;

  /**
   * ## What it does
   * Checks for implicit calls to possibly missing methods.
   *
   * ## Why is this bad?
   * Expressions such as `x[y]` and `x * y` call methods
   * under the hood (`__getitem__` and `__mul__` respectively).
   * Calling a missing method will raise an `AttributeError` at runtime.
   *
   * ## Examples
   * ```python
   * import datetime
   *
   * class A:
   * if datetime.date.today().weekday() != 6:
   * def __getitem__(self, v): ...
   *
   * A()[0]  # TypeError: 'A' object is not subscriptable
   * ```
   *
   * @schema Rules#possibly-missing-implicit-call
   */
  readonly possiblyMissingImplicitCall?: string;

  /**
   * ## What it does
   * Checks for imports of symbols that may be missing.
   *
   * ## Why is this bad?
   * Importing a missing module or name will raise a `ModuleNotFoundError`
   * or `ImportError` at runtime.
   *
   * ## Examples
   * ```python
   * # module.py
   * import datetime
   *
   * if datetime.date.today().weekday() != 6:
   * a = 1
   *
   * # main.py
   * from module import a  # ImportError: cannot import name 'a' from 'module'
   * ```
   *
   * @schema Rules#possibly-missing-import
   */
  readonly possiblyMissingImport?: string;

  /**
   * ## What it does
   * Checks for references to names that are possibly not defined.
   *
   * ## Why is this bad?
   * Using an undefined variable will raise a `NameError` at runtime.
   *
   * ## Example
   *
   * ```python
   * for i in range(0):
   * x = i
   *
   * print(x)  # NameError: name 'x' is not defined
   * ```
   *
   * @schema Rules#possibly-unresolved-reference
   */
  readonly possiblyUnresolvedReference?: string;

  /**
   * ## What it does
   * Checks for raw-strings in type annotation positions.
   *
   * ## Why is this bad?
   * Static analysis tools like ty can't analyze type annotations that use raw-string notation.
   *
   * ## Examples
   * ```python
   * def test(): -> r"int":
   * ...
   * ```
   *
   * Use instead:
   * ```python
   * def test(): -> "int":
   * ...
   * ```
   *
   * @schema Rules#raw-string-type-annotation
   */
  readonly rawStringTypeAnnotation?: string;

  /**
   * ## What it does
   * Detects redundant `cast` calls where the value already has the target type.
   *
   * ## Why is this bad?
   * These casts have no effect and can be removed.
   *
   * ## Example
   * ```python
   * def f() -> int:
   * return 10
   *
   * cast(int, f())  # Redundant
   * ```
   *
   * @schema Rules#redundant-cast
   */
  readonly redundantCast?: string;

  /**
   * ## What it does
   * Makes sure that the argument of `static_assert` is statically known to be true.
   *
   * ## Why is this bad?
   * A `static_assert` call represents an explicit request from the user
   * for the type checker to emit an error if the argument cannot be verified
   * to evaluate to `True` in a boolean context.
   *
   * ## Examples
   * ```python
   * from ty_extensions import static_assert
   *
   * static_assert(1 + 1 == 3)  # error: evaluates to `False`
   *
   * static_assert(int(2.0 * 3.0) == 6)  # error: does not have a statically known truthiness
   * ```
   *
   * @schema Rules#static-assert-error
   */
  readonly staticAssertError?: string;

  /**
   * ## What it does
   * Checks for classes that subclass final classes.
   *
   * ## Why is this bad?
   * Decorating a class with `@final` declares to the type checker that it should not be subclassed.
   *
   * ## Example
   *
   * ```python
   * from typing import final
   *
   * @final
   * class A: ...
   * class B(A): ...  # Error raised here
   * ```
   *
   * @schema Rules#subclass-of-final-class
   */
  readonly subclassOfFinalClass?: string;

  /**
   * ## What it does
   * Checks for calls that pass more positional arguments than the callable can accept.
   *
   * ## Why is this bad?
   * Passing too many positional arguments will raise `TypeError` at runtime.
   *
   * ## Example
   *
   * ```python
   * def f(): ...
   *
   * f("foo")  # Error raised here
   * ```
   *
   * @schema Rules#too-many-positional-arguments
   */
  readonly tooManyPositionalArguments?: string;

  /**
   * ## What it does
   * Checks for `assert_type()` and `assert_never()` calls where the actual type
   * is not the same as the asserted type.
   *
   * ## Why is this bad?
   * `assert_type()` allows confirming the inferred type of a certain value.
   *
   * ## Example
   *
   * ```python
   * def _(x: int):
   * assert_type(x, int)  # fine
   * assert_type(x, str)  # error: Actual type does not match asserted type
   * ```
   *
   * @schema Rules#type-assertion-failure
   */
  readonly typeAssertionFailure?: string;

  /**
   * ## What it does
   * Detects invalid `super()` calls where implicit arguments like the enclosing class or first method argument are unavailable.
   *
   * ## Why is this bad?
   * When `super()` is used without arguments, Python tries to find two things:
   * the nearest enclosing class and the first argument of the immediately enclosing function (typically self or cls).
   * If either of these is missing, the call will fail at runtime with a `RuntimeError`.
   *
   * ## Examples
   * ```python
   * super()  # error: no enclosing class or function found
   *
   * def func():
   * super()  # error: no enclosing class or first argument exists
   *
   * class A:
   * f = super()  # error: no enclosing function to provide the first argument
   *
   * def method(self):
   * def nested():
   * super()  # error: first argument does not exist in this nested function
   *
   * lambda: super()  # error: first argument does not exist in this lambda
   *
   * (super() for _ in range(10))  # error: argument is not available in generator expression
   *
   * super()  # okay! both enclosing class and first argument are available
   * ```
   *
   * ## References
   * - [Python documentation: super()](https://docs.python.org/3/library/functions.html#super)
   *
   * @schema Rules#unavailable-implicit-super-arguments
   */
  readonly unavailableImplicitSuperArguments?: string;

  /**
   * ## What it does
   * Checks for calls to `reveal_type` without importing it.
   *
   * ## Why is this bad?
   * Using `reveal_type` without importing it will raise a `NameError` at runtime.
   *
   * ## Examples
   * ```python
   * reveal_type(1)  # NameError: name 'reveal_type' is not defined
   * ```
   *
   * @schema Rules#undefined-reveal
   */
  readonly undefinedReveal?: string;

  /**
   * ## What it does
   * Checks for keyword arguments in calls that don't match any parameter of the callable.
   *
   * ## Why is this bad?
   * Providing an unknown keyword argument will raise `TypeError` at runtime.
   *
   * ## Example
   *
   * ```python
   * def f(x: int) -> int: ...
   *
   * f(x=1, y=2)  # Error raised here
   * ```
   *
   * @schema Rules#unknown-argument
   */
  readonly unknownArgument?: string;

  /**
   * ## What it does
   * Checks for unresolved attributes.
   *
   * ## Why is this bad?
   * Accessing an unbound attribute will raise an `AttributeError` at runtime.
   * An unresolved attribute is not guaranteed to exist from the type alone,
   * so this could also indicate that the object is not of the type that the user expects.
   *
   * ## Examples
   * ```python
   * class A: ...
   *
   * A().foo  # AttributeError: 'A' object has no attribute 'foo'
   * ```
   *
   * @schema Rules#unresolved-attribute
   */
  readonly unresolvedAttribute?: string;

  /**
   * ## What it does
   * Detects variables declared as `global` in an inner scope that have no explicit
   * bindings or declarations in the global scope.
   *
   * ## Why is this bad?
   * Function bodies with `global` statements can run in any order (or not at all), which makes
   * it hard for static analysis tools to infer the types of globals without
   * explicit definitions or declarations.
   *
   * ## Example
   * ```python
   * def f():
   * global x  # unresolved global
   * x = 42
   *
   * def g():
   * print(x)  # unresolved reference
   * ```
   *
   * Use instead:
   *
   * ```python
   * x: int
   *
   * def f():
   * global x
   * x = 42
   *
   * def g():
   * print(x)
   * ```
   *
   * Or:
   *
   * ```python
   * x: int | None = None
   *
   * def f():
   * global x
   * x = 42
   *
   * def g():
   * print(x)
   * ```
   *
   * @schema Rules#unresolved-global
   */
  readonly unresolvedGlobal?: string;

  /**
   * ## What it does
   * Checks for import statements for which the module cannot be resolved.
   *
   * ## Why is this bad?
   * Importing a module that cannot be resolved will raise a `ModuleNotFoundError`
   * at runtime.
   *
   * ## Examples
   * ```python
   * import foo  # ModuleNotFoundError: No module named 'foo'
   * ```
   *
   * @schema Rules#unresolved-import
   */
  readonly unresolvedImport?: string;

  /**
   * ## What it does
   * Checks for references to names that are not defined.
   *
   * ## Why is this bad?
   * Using an undefined variable will raise a `NameError` at runtime.
   *
   * ## Example
   *
   * ```python
   * print(x)  # NameError: name 'x' is not defined
   * ```
   *
   * @schema Rules#unresolved-reference
   */
  readonly unresolvedReference?: string;

  /**
   * ## What it does
   * Checks for class definitions that have bases which are unsupported by ty.
   *
   * ## Why is this bad?
   * If a class has a base that is an instance of a complex type such as a union type,
   * ty will not be able to resolve the [method resolution order] (MRO) for the class.
   * This will lead to an inferior understanding of your codebase and unpredictable
   * type-checking behavior.
   *
   * ## Examples
   * ```python
   * import datetime
   *
   * class A: ...
   * class B: ...
   *
   * if datetime.date.today().weekday() != 6:
   * C = A
   * else:
   * C = B
   *
   * class D(C): ...  # error: [unsupported-base]
   * ```
   *
   * [method resolution order]: https://docs.python.org/3/glossary.html#term-method-resolution-order
   *
   * @schema Rules#unsupported-base
   */
  readonly unsupportedBase?: string;

  /**
   * ## What it does
   * Checks for bool conversions where the object doesn't correctly implement `__bool__`.
   *
   * ## Why is this bad?
   * If an exception is raised when you attempt to evaluate the truthiness of an object,
   * using the object in a boolean context will fail at runtime.
   *
   * ## Examples
   *
   * ```python
   * class NotBoolable:
   * __bool__ = None
   *
   * b1 = NotBoolable()
   * b2 = NotBoolable()
   *
   * if b1:  # exception raised here
   * pass
   *
   * b1 and b2  # exception raised here
   * not b1  # exception raised here
   * b1 < b2 < b1  # exception raised here
   * ```
   *
   * @schema Rules#unsupported-bool-conversion
   */
  readonly unsupportedBoolConversion?: string;

  /**
   * ## What it does
   * Checks for binary expressions, comparisons, and unary expressions where
   * the operands don't support the operator.
   *
   * ## Why is this bad?
   * Attempting to use an unsupported operator will raise a `TypeError` at
   * runtime.
   *
   * ## Examples
   * ```python
   * class A: ...
   *
   * A() + A()  # TypeError: unsupported operand type(s) for +: 'A' and 'A'
   * ```
   *
   * @schema Rules#unsupported-operator
   */
  readonly unsupportedOperator?: string;

  /**
   * ## What it does
   * Checks for `type: ignore` or `ty: ignore` directives that are no longer applicable.
   *
   * ## Why is this bad?
   * A `type: ignore` directive that no longer matches any diagnostic violations is likely
   * included by mistake, and should be removed to avoid confusion.
   *
   * ## Examples
   * ```py
   * a = 20 / 2  # ty: ignore[division-by-zero]
   * ```
   *
   * Use instead:
   *
   * ```py
   * a = 20 / 2
   * ```
   *
   * @schema Rules#unused-ignore-comment
   */
  readonly unusedIgnoreComment?: string;

  /**
   * ## What it does
   * Checks for various `@overload`-decorated functions that have non-stub bodies.
   *
   * ## Why is this bad?
   * Functions decorated with `@overload` are ignored at runtime; they are overridden
   * by the implementation function that follows the series of overloads. While it is
   * not illegal to provide a body for an `@overload`-decorated function, it may indicate
   * a misunderstanding of how the `@overload` decorator works.
   *
   * ## Example
   *
   * ```py
   * from typing import overload
   *
   * @overload
   * def foo(x: int) -> int:
   * return x + 1  # will never be executed
   *
   * @overload
   * def foo(x: str) -> str:
   * return "Oh no, got a string"  # will never be executed
   *
   * def foo(x: int | str) -> int | str:
   * raise Exception("unexpected type encountered")
   * ```
   *
   * Use instead:
   *
   * ```py
   * from typing import assert_never, overload
   *
   * @overload
   * def foo(x: int) -> int: ...
   *
   * @overload
   * def foo(x: str) -> str: ...
   *
   * def foo(x: int | str) -> int | str:
   * if isinstance(x, int):
   * return x + 1
   * elif isinstance(x, str):
   * return "Oh no, got a string"
   * else:
   * assert_never(x)
   * ```
   *
   * ## References
   * - [Python documentation: `@overload`](https://docs.python.org/3/library/typing.html#typing.overload)
   *
   * @schema Rules#useless-overload-body
   */
  readonly uselessOverloadBody?: string;

  /**
   * ## What it does
   * Checks for step size 0 in slices.
   *
   * ## Why is this bad?
   * A slice with a step size of zero will raise a `ValueError` at runtime.
   *
   * ## Examples
   * ```python
   * l = list(range(10))
   * l[1:10:0]  # ValueError: slice step cannot be zero
   * ```
   *
   * @schema Rules#zero-stepsize-in-slice
   */
  readonly zeroStepsizeInSlice?: string;
}

/**
 * Converts an object of type 'Rules' to JSON representation.
 * @internal
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_Rules(obj: Rules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ambiguous-protocol-member': obj.ambiguousProtocolMember,
    'byte-string-type-annotation': obj.byteStringTypeAnnotation,
    'call-non-callable': obj.callNonCallable,
    'conflicting-argument-forms': obj.conflictingArgumentForms,
    'conflicting-declarations': obj.conflictingDeclarations,
    'conflicting-metaclass': obj.conflictingMetaclass,
    'cyclic-class-definition': obj.cyclicClassDefinition,
    'deprecated': obj.deprecated,
    'division-by-zero': obj.divisionByZero,
    'duplicate-base': obj.duplicateBase,
    'duplicate-kw-only': obj.duplicateKwOnly,
    'escape-character-in-forward-annotation': obj.escapeCharacterInForwardAnnotation,
    'fstring-type-annotation': obj.fstringTypeAnnotation,
    'ignore-comment-unknown-rule': obj.ignoreCommentUnknownRule,
    'implicit-concatenated-string-type-annotation': obj.implicitConcatenatedStringTypeAnnotation,
    'inconsistent-mro': obj.inconsistentMro,
    'index-out-of-bounds': obj.indexOutOfBounds,
    'instance-layout-conflict': obj.instanceLayoutConflict,
    'invalid-argument-type': obj.invalidArgumentType,
    'invalid-assignment': obj.invalidAssignment,
    'invalid-attribute-access': obj.invalidAttributeAccess,
    'invalid-await': obj.invalidAwait,
    'invalid-base': obj.invalidBase,
    'invalid-context-manager': obj.invalidContextManager,
    'invalid-declaration': obj.invalidDeclaration,
    'invalid-exception-caught': obj.invalidExceptionCaught,
    'invalid-generic-class': obj.invalidGenericClass,
    'invalid-ignore-comment': obj.invalidIgnoreComment,
    'invalid-key': obj.invalidKey,
    'invalid-legacy-type-variable': obj.invalidLegacyTypeVariable,
    'invalid-metaclass': obj.invalidMetaclass,
    'invalid-named-tuple': obj.invalidNamedTuple,
    'invalid-newtype': obj.invalidNewtype,
    'invalid-overload': obj.invalidOverload,
    'invalid-parameter-default': obj.invalidParameterDefault,
    'invalid-paramspec': obj.invalidParamspec,
    'invalid-protocol': obj.invalidProtocol,
    'invalid-raise': obj.invalidRaise,
    'invalid-return-type': obj.invalidReturnType,
    'invalid-super-argument': obj.invalidSuperArgument,
    'invalid-syntax-in-forward-annotation': obj.invalidSyntaxInForwardAnnotation,
    'invalid-type-alias-type': obj.invalidTypeAliasType,
    'invalid-type-checking-constant': obj.invalidTypeCheckingConstant,
    'invalid-type-form': obj.invalidTypeForm,
    'invalid-type-guard-call': obj.invalidTypeGuardCall,
    'invalid-type-guard-definition': obj.invalidTypeGuardDefinition,
    'invalid-type-variable-constraints': obj.invalidTypeVariableConstraints,
    'missing-argument': obj.missingArgument,
    'missing-typed-dict-key': obj.missingTypedDictKey,
    'no-matching-overload': obj.noMatchingOverload,
    'non-subscriptable': obj.nonSubscriptable,
    'not-iterable': obj.notIterable,
    'parameter-already-assigned': obj.parameterAlreadyAssigned,
    'positional-only-parameter-as-kwarg': obj.positionalOnlyParameterAsKwarg,
    'possibly-missing-attribute': obj.possiblyMissingAttribute,
    'possibly-missing-implicit-call': obj.possiblyMissingImplicitCall,
    'possibly-missing-import': obj.possiblyMissingImport,
    'possibly-unresolved-reference': obj.possiblyUnresolvedReference,
    'raw-string-type-annotation': obj.rawStringTypeAnnotation,
    'redundant-cast': obj.redundantCast,
    'static-assert-error': obj.staticAssertError,
    'subclass-of-final-class': obj.subclassOfFinalClass,
    'too-many-positional-arguments': obj.tooManyPositionalArguments,
    'type-assertion-failure': obj.typeAssertionFailure,
    'unavailable-implicit-super-arguments': obj.unavailableImplicitSuperArguments,
    'undefined-reveal': obj.undefinedReveal,
    'unknown-argument': obj.unknownArgument,
    'unresolved-attribute': obj.unresolvedAttribute,
    'unresolved-global': obj.unresolvedGlobal,
    'unresolved-import': obj.unresolvedImport,
    'unresolved-reference': obj.unresolvedReference,
    'unsupported-base': obj.unsupportedBase,
    'unsupported-bool-conversion': obj.unsupportedBoolConversion,
    'unsupported-operator': obj.unsupportedOperator,
    'unused-ignore-comment': obj.unusedIgnoreComment,
    'useless-overload-body': obj.uselessOverloadBody,
    'zero-stepsize-in-slice': obj.zeroStepsizeInSlice,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema SrcOptions
 */
export interface SrcOptions {
  /**
   * A list of file and directory patterns to exclude from type checking.
   *
   * Patterns follow a syntax similar to `.gitignore`:
   *
   * - `./src/` matches only a directory
   * - `./src` matches both files and directories
   * - `src` matches files or directories named `src`
   * - `*` matches any (possibly empty) sequence of characters (except `/`).
   * - `**` matches zero or more path components.
   * This sequence **must** form a single path component, so both `**a` and `b**` are invalid and will result in an error.
   * A sequence of more than two consecutive `*` characters is also invalid.
   * - `?` matches any single character except `/`
   * - `[abc]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,
   * so e.g. `[0-9]` specifies any character between `0` and `9` inclusive. An unclosed bracket is invalid.
   * - `!pattern` negates a pattern (undoes the exclusion of files that would otherwise be excluded)
   *
   * All paths are anchored relative to the project root (`src` only
   * matches `<project_root>/src` and not `<project_root>/test/src`).
   * To exclude any directory or file named `src`, use `*_/src` instead.
   *
   * By default, ty excludes commonly ignored directories:
   *
   * - `*_/.bzr/`
   * - `*_/.direnv/`
   * - `*_/.eggs/`
   * - `*_/.git/`
   * - `*_/.git-rewrite/`
   * - `*_/.hg/`
   * - `*_/.mypy_cache/`
   * - `*_/.nox/`
   * - `*_/.pants.d/`
   * - `*_/.pytype/`
   * - `*_/.ruff_cache/`
   * - `*_/.svn/`
   * - `*_/.tox/`
   * - `*_/.venv/`
   * - `*_/__pypackages__/`
   * - `*_/_build/`
   * - `*_/buck-out/`
   * - `*_/dist/`
   * - `*_/node_modules/`
   * - `*_/venv/`
   *
   * You can override any default exclude by using a negated pattern. For example,
   * to re-include `dist` use `exclude = ["!dist"]`
   *
   * @schema SrcOptions#exclude
   */
  readonly exclude?: string[];

  /**
   * A list of files and directories to check. The `include` option
   * follows a similar syntax to `.gitignore` but reversed:
   * Including a file or directory will make it so that it (and its contents)
   * are type checked.
   *
   * - `./src/` matches only a directory
   * - `./src` matches both files and directories
   * - `src` matches a file or directory named `src`
   * - `*` matches any (possibly empty) sequence of characters (except `/`).
   * - `**` matches zero or more path components.
   * This sequence **must** form a single path component, so both `**a` and `b**` are invalid and will result in an error.
   * A sequence of more than two consecutive `*` characters is also invalid.
   * - `?` matches any single character except `/`
   * - `[abc]` matches any character inside the brackets. Character sequences can also specify ranges of characters, as ordered by Unicode,
   * so e.g. `[0-9]` specifies any character between `0` and `9` inclusive. An unclosed bracket is invalid.
   *
   * All paths are anchored relative to the project root (`src` only
   * matches `<project_root>/src` and not `<project_root>/test/src`).
   *
   * `exclude` takes precedence over `include`.
   *
   * @schema SrcOptions#include
   */
  readonly include?: string[];

  /**
   * Whether to automatically exclude files that are ignored by `.ignore`,
   * `.gitignore`, `.git/info/exclude`, and global `gitignore` files.
   * Enabled by default.
   *
   * @schema SrcOptions#respect-ignore-files
   */
  readonly respectIgnoreFiles?: boolean;

  /**
   * The root of the project, used for finding first-party modules.
   *
   * If left unspecified, ty will try to detect common project layouts and initialize `src.root` accordingly:
   *
   * * if a `./src` directory exists, include `.` and `./src` in the first party search path (src layout or flat)
   * * if a `./<project-name>/<project-name>` directory exists, include `.` and `./<project-name>` in the first party search path
   * * otherwise, default to `.` (flat layout)
   *
   * Besides, if a `./tests` directory exists and is not a package (i.e. it does not contain an `__init__.py` file),
   * it will also be included in the first party search path.
   *
   * @schema SrcOptions#root
   */
  readonly root?: string;
}

/**
 * Converts an object of type 'SrcOptions' to JSON representation.
 * @internal
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_SrcOptions(obj: SrcOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exclude': obj.exclude?.map(y => y),
    'include': obj.include?.map(y => y),
    'respect-ignore-files': obj.respectIgnoreFiles,
    'root': obj.root,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TerminalOptions
 */
export interface TerminalOptions {
  /**
   * Use exit code 1 if there are any warning-level diagnostics.
   *
   * Defaults to `false`.
   *
   * @default false`.
   * @schema TerminalOptions#error-on-warning
   */
  readonly errorOnWarning?: boolean;

  /**
   * The format to use for printing diagnostic messages.
   *
   * Defaults to `full`.
   *
   * @default full`.
   * @schema TerminalOptions#output-format
   */
  readonly outputFormat?: string;
}

/**
 * Converts an object of type 'TerminalOptions' to JSON representation.
 * @internal
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TerminalOptions(obj: TerminalOptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'error-on-warning': obj.errorOnWarning,
    'output-format': obj.outputFormat,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
